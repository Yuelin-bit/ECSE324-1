
C:/Users/Alex/Documents/McGill/ECSE_324/Labs/ECSE324/Lab 3/HEX_test/hex.axf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <__cs3_interrupt_vector>:
	// .global HEX_flood_ASM
	// .global HEX_write_ASM
	.global _start

_start:
	MOV R0, #63
   0:	e3a0003f 	mov	r0, #63	; 0x3f
	MOV R1, #10
   4:	e3a0100a 	mov	r1, #10
	B HEX_write_ASM
   8:	ea000004 	b	20 <HEX_write_ASM>

0000000c <CLEAR>:

CLEAR:	MOV R0, #63
   c:	e3a0003f 	mov	r0, #63	; 0x3f

00000010 <HEX_clear_ASM>:
			B CLEAR

/*------------------------------------------------------------------------------------*/

HEX_clear_ASM:			// turn off everything in the requested hex displays
	LDRB R2, ZEROS		// load 00000000 into R2
  10:	e5df2064 	ldrb	r2, [pc, #100]	; 7c <ZEROS>
	B RUN
  14:	ea000004 	b	2c <RUN>

00000018 <HEX_flood_ASM>:

HEX_flood_ASM:			// light up everything in the requested hex displays
	LDRB R2, ONES		// load 11111111 into R1
  18:	e5df205d 	ldrb	r2, [pc, #93]	; 7d <ONES>
	B RUN
  1c:	ea000002 	b	2c <RUN>

00000020 <HEX_write_ASM>:

HEX_write_ASM:			// display the corresponding hexadecimal digit in the requested hex displays
	LDR R2, =LIGHTS		// hold address of first encoded light sequence
  20:	e59f2068 	ldr	r2, [pc, #104]	; 90 <LIGHTS+0x12>
	LDRB R2, [R2, R1]	// put appropriate 1 byte encoded light sequence into R2, using base address + shift according to input
  24:	e7d22001 	ldrb	r2, [r2, r1]
	B RUN
  28:	eaffffff 	b	2c <RUN>

0000002c <RUN>:

RUN:
	PUSH {LR}
  2c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	MOV R8, #32			// R8 holds the current power of 2 that is being used for comparison
  30:	e3a08020 	mov	r8, #32
	MOV R9, #1			// R9 holds the memory offset counter
  34:	e3a09001 	mov	r9, #1
	LDR R10, =HEX_4to5	// R10 holds the starting address of the area in memory
  38:	e59fa054 	ldr	r10, [pc, #84]	; 94 <LIGHTS+0x16>

0000003c <LOOP>:
	
LOOP:
	CMP R8, #0			// check if power-of-2 counter has reached zero
  3c:	e3580000 	cmp	r8, #0
	BEQ	END				// if so, branch to end
  40:	0a000007 	beq	64 <END>
	CMP R8, #8			// check if power-of-2 counter has reached 8, meaning it's on HEX0-HEX4
  44:	e3580008 	cmp	r8, #8
	BEQ N				// if on threshold, go to 'change values' block
  48:	0a000008 	beq	70 <N>

0000004c <A>:
A: 	CMP R0, R8			// check if input value >= power-of-2 counter
  4c:	e1500008 	cmp	r0, r8
	BLT S				// if no, the leftmost bit must be zero => skip a line
  50:	ba000000 	blt	58 <S>
	STRB R2, [R10, R9]	// if yes, leftmost bit is 1 => store the predetermined byte into the base memory location + the offset
  54:	e7ca2009 	strb	r2, [r10, r9]

00000058 <S>:
S:  LSR R8, #1			// decrease power-of-2 counter by one power of 2
  58:	e1a080a8 	lsr	r8, r8, #1
	SUB R9, R9, #1		// decrease memory offset counter by four
  5c:	e2499001 	sub	r9, r9, #1
	B LOOP
  60:	eafffff5 	b	3c <LOOP>

00000064 <END>:


END:	B END
  64:	eafffffe 	b	64 <END>
		POP {LR}
  68:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
		BX LR			// leave
  6c:	e12fff1e 	bx	lr

00000070 <N>:

N:	LDR R10, =HEX_0to3	// change to other memory location
  70:	e59fa020 	ldr	r10, [pc, #32]	; 98 <LIGHTS+0x1a>
	MOV R9, #3			// update memory offset counter
  74:	e3a09003 	mov	r9, #3
	B A					// go back
  78:	eafffff3 	b	4c <A>

0000007c <ZEROS>:
	...

0000007d <ONES>:
  7d:	7f          	.byte	0x7f

0000007e <LIGHTS>:
  7e:	061f      	.short	0x061f
  80:	6d664f5b 	.word	0x6d664f5b
  84:	673f077d 	.word	0x673f077d
  88:	063c7c77 	.word	0x063c7c77
  8c:	0000787c 	.word	0x0000787c
  90:	0000007e 	.word	0x0000007e
  94:	ff200030 	.word	0xff200030
  98:	ff200020 	.word	0xff200020
